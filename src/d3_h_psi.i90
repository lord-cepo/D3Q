# 1 "/linkhome/rech/genimp01/unr46rr/work/qe-7.2-tetra/D3Q/src/d3_h_psi.f90"
!
! Copyright (C) 2001 PWSCF group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
MODULE d3_h_psi
! **********************************************************************
! *                   ~~~ IMPORTANT NOTE ~~~                           *
! * These subroutines are never CALLed explicitly in the D3 code!!!    *
! * They're instead USEd in solve_linter_d3q where they are passed     *
! * to the phonon subroutine PH/cgsolve_all.f90                        *
! * and used. Be extremely careful when changing global variables to   *
! * local ones as it may break something!!!                            *
! * In particular igkq=>igk_prj should NOT be touched lightheartedly.  *
! **********************************************************************

  USE kinds, ONLY : DP
!
!USE wvfct, ONLY : igk_prj => igk
  USE qpoint, ONLY : igkq
  USE wvfct,  ONLY : g2kin_prj => g2kin ! used in solve_linter_d3q
  USE uspp,   ONLY : vkb_prj => vkb
!
!PRIVATE
! They compute:
  PUBLIC :: d3_ch_psi, & ! ( H - \epsilon S + alpha_pv P_v)
            d3_cg_psi    ! preconditioning

! note : h_psiq from phonon is used instead of the internal version
!   PUBLIC :: d3_h_psiq, & !  (H \psi) and (S \psi)
!
  INTEGER :: nproj
  INTEGER,ALLOCATABLE,PUBLIC        :: igk_wfc(:)
  INTEGER,ALLOCATABLE,TARGET,PUBLIC :: igk_prj(:)
  COMPLEX(DP),ALLOCATABLE,PUBLIC :: vkb_wfc(:,:)!, vkb_prj(:,:)
  COMPLEX(DP),ALLOCATABLE,PUBLIC :: psi_prj(:,:), psi_wfc(:,:)
!PUBLIC :: igk_prj, g2kin_prj, vkb_prj, nproj

CONTAINS
!-----------------------------------------------------------------------
SUBROUTINE d3_ch_psi(n, h, ah, e, ik, m)
!-----------------------------------------------------------------------
!
! This routine applies the operator ( H - \epsilon S + alpha_pv P_v)
! to a vector h. The result is given in Ah.
!
  USE kinds,      ONLY : DP
  USE wvfct,      ONLY : npwx!, nbnd
! USE uspp,       ONLY : vkb
  USE becmod,     ONLY : becp, calbec
  USE control_lr, ONLY : alpha_pv
  USE mp_pools,   ONLY : intra_pool_comm
  USE mp,         ONLY : mp_sum
!   USE linter_d3q, ONLY : igk_prj, wfc_prj, vkb_prj
!
  IMPLICIT NONE
  INTEGER,INTENT(in) :: n, m, ik
! input: the dimension of h
! input: the number of bands
! input: the k point

  REAL(DP),INTENT(in) :: e (m)
! input: the eigenvalue

  COMPLEX(DP),INTENT(in)  :: h (npwx, m)
! input: the vector
  COMPLEX(DP),INTENT(out) :: ah (npwx, m)
! output: the operator applied to the vector
!
!   local variables
!

  INTEGER :: ibnd,ig
! counter on bands
! the point k+q
! counter on G vetors

  COMPLEX (DP), ALLOCATABLE :: ps (:,:), hpsi (:,:), spsi (:,:)
! scalar products
! the product of the Hamiltonian and h
! the product of the S matrix and h


  CALL start_clock ('ch_psi')
  ALLOCATE (ps( nproj, m))
  ALLOCATE (hpsi( npwx, m))
  ALLOCATE (spsi( npwx, m))

  hpsi = (0.d0, 0.d0)
  spsi = (0.d0, 0.d0)
!
!   compute the product of the hamiltonian with the h vector
!
  igkq => igk_prj ! <-- igkq is hard-coded inside h_psiq
  CALL h_psiq (npwx, n, m, h, hpsi, spsi) !, igk_prj)
  NULLIFY(igkq)

!CALL start_clock ('last')
!
!   then we compute the operator H-epsilon S
!
  DO ibnd = 1, m
     DO ig = 1, n
        ah (ig, ibnd) = hpsi (ig, ibnd) - e (ibnd) * spsi (ig, ibnd)
     ENDDO
  ENDDO
!
!   Here we compute the projector in the valence band
!
  hpsi = (0.d0, 0.d0)
!
  ps = (0.d0, 0.d0)

  CALL zgemm ('C', 'N', nproj, m, n, (1.d0, 0.d0) , psi_prj, npwx, spsi, &
       npwx, (0.d0, 0.d0) , ps, nproj)
  ps = ps * alpha_pv
# 121


  CALL zgemm ('N', 'N', n, m, nproj, (1.d0, 0.d0) , psi_prj, npwx, ps, &
       nproj, (1.d0, 0.d0) , hpsi, npwx)
  spsi = hpsi
!
!    And apply S again
!
  CALL calbec (n, vkb_prj, hpsi, becp, m)
  CALL s_psi (npwx, n, m, hpsi, spsi)
  DO ibnd = 1, m
     DO ig = 1, n
        ah (ig, ibnd) = ah (ig, ibnd) + spsi (ig, ibnd)
     ENDDO
  ENDDO

  DEALLOCATE (spsi)
  DEALLOCATE (hpsi)
  DEALLOCATE (ps)
!CALL stop_clock ('last')
  CALL stop_clock ('ch_psi')
  RETURN
END SUBROUTINE d3_ch_psi

!-----------------------------------------------------------------
SUBROUTINE d3_cg_psi (lda, n, m, psi, h_diag)
!-----------------------------------------------------------------
!
!    This routine gives a preconditioning to the linear system solver.
!    The preconditioning is diagonal in reciprocal space
!
!
  USE kinds,            ONLY : DP
  USE noncollin_module, ONLY : npol !, noncolin
  IMPLICIT NONE

  INTEGER,INTENT(in) :: lda, n, m
! input: the leading dimension of the psi vector
! input: the real dimension of the vector
! input: the number of vectors

  COMPLEX(DP) :: psi (lda*npol, m)
! inp/out: the vector to be preconditioned

  REAL(DP) :: h_diag (lda*npol, m)
! input: the preconditioning vector

  INTEGER :: k, i
! counter on bands
! counter on the elements of the vector
!
  DO k = 1, m
     DO i = 1, n
        psi (i, k) = psi (i, k) * h_diag (i, k)
     ENDDO
  ENDDO
!   IF (noncolin) THEN
!      DO k = 1, m
!         DO i = 1, n
!            psi (i+lda, k) = psi (i+lda, k) * h_diag (i+lda, k)
!         ENDDO
!      ENDDO
!   END IF
  RETURN
END SUBROUTINE d3_cg_psi

# 336


END MODULE d3_h_psi
